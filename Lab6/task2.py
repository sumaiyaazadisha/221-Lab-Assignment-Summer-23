# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cnh2zV2fPdGBoV14rRLSboS8Z35HrSLp
"""

# Task-02
import heapq
input = open('/content/input2.txt', 'r')
output= open('/content/output2.txt','w')
vertex, edge = map(int, input.readline().rstrip().split())
G = {}
for i in range(1, vertex + 1):
    G[i] = []
for x in range(edge):
    v, e, w = map(int, input.readline().rstrip().split())
    G[v].append((e, w))

source1, source2 = map(int, input.readline().rstrip().split())


def shortest_path(G, s):
    priority_queue = []
    heapq.heappush(priority_queue, (s, 0))

    distance = [float('inf')] * (vertex + 1)
    distance[s] = 0

    while priority_queue != []:
        ver, dis = heapq.heappop(priority_queue)
        for edge, weight in G[ver]:
            if distance[edge] > distance[ver] + weight:
                distance[edge] = distance[ver] + weight
                heapq.heappush(priority_queue, (edge, distance[edge]))
    return distance

def meeting_point(G, source1, source2):
    min_time = float('inf')
    distance_1 = shortest_path(G, source1)
    distance_2 = shortest_path(G, source2)
    min_time_list = [float('inf')] * (vertex + 1)
    for ver in G.keys():
        total_dis = distance_1[ver] + distance_2[ver]
        if total_dis < min_time:
            min_time_list[ver] = max(distance_1[ver], distance_2[ver])

    if min(min_time_list) == float('inf'):
        return "IMPOSSIBLE"
    else:
        return f"Time: {min(min_time_list)}\nNode: {min_time_list.index(min(min_time_list))}"


print(meeting_point(G, source1, source2), file = output)
output.close()