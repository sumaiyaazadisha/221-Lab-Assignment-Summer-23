# -*- coding: utf-8 -*-
"""task1(b)ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xMkANoZxgOFN3mB6DHguDImgz9izEh-B
"""

# Task-01(b)(BFS)
input = open('/content/input1.txt', 'r')
output = open('/content/output1(b).txt', 'w')
vertex,edge = map(int, input.readline().rstrip().split())

G = {}
for i in range(1, vertex + 1):
    G[i] = []
for x in range(edge):
    v,e = map(int, input.readline().rstrip().split())
    G[v].append(e)

# for cycle check
def check(V, visited, stack):
    if stack[V] == True:
        return True

    if visited[V] == True:
        return False

    visited[V] = True
    stack[V] = True
    for ver in G[V]:
        if check(ver, visited, stack) == True:
            return True
    stack[V] = False
    return False

def cycle_check(G, Start):
    visited = [False] * (Start + 1)
    stack = [False] * (Start + 1)
    for key in G.keys():
        if check(key, visited, stack) == True:
            return True
    return False


def topologicalSort(G):
    in_degree = [0] * (vertex + 1)
    for ver in G.keys():
        for ele in G[ver]:
            in_degree[ele] += 1
        queue = []
    for i in G.keys():
        if in_degree[i] == 0:
            queue.append(i)

    top_order = []
    while queue:
        u = queue.pop(0)
        top_order.append(u)

        for i in G[u]:
            in_degree[i] -= 1
            if in_degree[i] == 0:
                queue.append(i)
    return top_order


if cycle_check(G, vertex) == True:
    print("IMPOSSIBLE", file = output)
else:
    print(topologicalSort(G), file = output)

output.close()